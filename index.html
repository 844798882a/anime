<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨æ¼«è¯„åˆ†æ®¿å ‚</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* CSSæ ·å¼ä¸ä¹‹å‰ç‰ˆæœ¬å®Œå…¨ç›¸åŒï¼Œæ­¤å¤„çœç•¥ä»¥ä¿æŒç®€æ´ã€‚å®é™…ä½¿ç”¨æ—¶è¯·å°†ä¸Šä¸€ä¸ªå›ç­”ä¸­çš„<style>å†…å®¹å®Œæ•´å¤åˆ¶åˆ°è¿™é‡Œã€‚ */
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --text-muted-color: #a0a0a0;
            --border-color: #2a2a4a;
            --hover-bg-color: #1f2b4e;
        }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            margin: 0;
            padding: 40px 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            transition: background-image 1.5s ease-in-out;
        }

        .container {
            max-width: 1600px;
            margin: auto;
            background: rgba(22, 33, 62, 0.9);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
            animation: fadeInSlideUp 0.8s ease-out forwards;
        }

        @keyframes fadeInSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            text-align: center;
            color: #fff;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 30px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .search-box {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 16px;
            background-color: var(--primary-color);
            color: var(--text-color);
            width: 250px;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        .tag-filter button {
            padding: 8px 15px;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0 5px;
            transition: all 0.3s ease;
        }

        .tag-filter button:hover {
            background-color: var(--hover-bg-color);
        }

        .tag-filter button.active {
            background-color: var(--accent-color);
            color: #fff;
            border-color: var(--accent-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.95em;
        }

        th, td {
            padding: 12px 10px;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
        }

        th {
            background-color: rgba(15, 52, 96, 0.5);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            font-weight: 400;
        }
        
        tr {
            transition: all 0.2s ease-out;
        }

        tbody tr:hover {
            background-color: var(--hover-bg-color);
            transform: scale(1.01);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            z-index: 10;
            position: relative;
        }
        
        th .sort-indicator {
            float: right;
            margin-left: 5px;
            color: var(--text-muted-color);
        }
        
        th.sorted-asc .sort-indicator,
        th.sorted-desc .sort-indicator {
            color: #fff;
        }

        .anime-img {
            width: 70px;
            height: 105px;
            object-fit: cover;
            border-radius: 6px;
            display: block;
            margin: auto;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .score {
            font-weight: 700;
            font-size: 1.1em;
            cursor: pointer;
            color: #61dafb;
            text-decoration: none;
            display: inline-block;
            transition: color 0.3s;
        }
        .score:hover {
            color: var(--accent-color);
            text-shadow: 0 0 8px var(--accent-color);
        }
        
        td strong {
             font-size: 1.1em;
             font-weight: 700;
        }

        .tags span {
            background-color: var(--secondary-color);
            padding: 4px 10px;
            border-radius: 12px;
            margin: 2px;
            font-size: 0.85em;
            display: inline-block;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.4s;
        }

        .modal-content {
            background-color: var(--primary-color);
            color: var(--text-color);
            margin: 12% auto;
            padding: 25px;
            border: 1px solid var(--border-color);
            width: 80%;
            max-width: 550px;
            border-radius: 10px;
            position: relative;
            animation: slideIn 0.4s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        @keyframes fadeIn { from {opacity: 0;} to {opacity: 1;} }
        @keyframes slideIn { from {transform: translateY(-50px);} to {transform: translateY(0);} }

        .close-btn {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 32px;
            font-weight: bold;
            transition: color 0.3s;
        }

        .close-btn:hover, .close-btn:focus { color: var(--accent-color); text-decoration: none; cursor: pointer; }
        
        .details-comment {
            font-size: 0.9em;
            color: var(--text-muted-color);
            margin-top: 5px;
            font-weight: 300;
        }

        #modal-content-details {
            line-height: 1.7;
        }

        /* Controls for background and music */
        .media-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 999;
        }
        .control-group {
            background: rgba(22, 33, 62, 0.8);
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        .media-controls button {
            background: var(--secondary-color);
            border: 1px solid var(--border-color);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .media-controls button:hover {
            background: var(--accent-color);
        }
        .music-info {
            font-size: 12px;
            text-align: center;
            color: var(--text-muted-color);
            width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>åŠ¨æ¼«è¯„åˆ†æ®¿å ‚</h1>
        <div class="controls">
            <input type="text" id="searchInput" class="search-box" onkeyup="filterTable()" placeholder="æœç´¢åŠ¨æ¼«åç§°...">
            <div id="tagFilterContainer" class="tag-filter"><span>ç­›é€‰æ ‡ç­¾: </span></div>
        </div>
        <table id="animeTable">
            <thead>
                <tr>
                    <th style="width: 90px; text-align: center;">å›¾ç‰‡</th>
                    <th data-sort="name">åç§° <span class="sort-indicator">â†•</span></th>
                    <th data-sort="personalScore">ä¸ªäººè¯„åˆ† <span class="sort-indicator">â†•</span></th>
                    <th data-sort="production">åˆ¶ä½œ(30%) <span class="sort-indicator">â†•</span></th>
                    <th data-sort="plot">å‰§æƒ…(40%) <span class="sort-indicator">â†•</span></th>
                    <th data-sort="character">è§’è‰²(30%) <span class="sort-indicator">â†•</span></th>
                    <th data-sort="recommendationScore">æ¨èæ€»åˆ† <span class="sort-indicator">â†•</span></th>
                    <th data-sort="adjustmentScore">ä¿®æ­£åˆ†æ•° <span class="sort-indicator">â†•</span></th>
                    <th data-sort="finalScore">æœ€ç»ˆå¾—åˆ† <span class="sort-indicator">â†•</span></th>
                    <th>æ ‡ç­¾</th>
                    <th data-sort="date" class="sorted-desc">æ—¶é—´ <span class="sort-indicator">â†“</span></th>
                    <th data-sort="bangumiScore">Bangumi <span class="sort-indicator">â†•</span></th>
                </tr>
            </thead>
            <tbody id="animeTableBody"></tbody>
        </table>
    </div>

    <div id="detailsModal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2 id="modalTitle"></h2>
            <div id="modal-content-details"></div>
        </div>
    </div>

    <div class="media-controls">
        <div class="control-group">
            <button id="prevBgBtn" title="ä¸Šä¸€å¼ èƒŒæ™¯">ğŸ–¼ï¸</button>
            <button id="nextBgBtn" title="ä¸‹ä¸€å¼ èƒŒæ™¯">ğŸ–¼ï¸</button>
        </div>
        <div class="control-group">
            <button id="playPauseBtn" title="æ’­æ”¾/æš‚åœ">â–¶ï¸</button>
            <button id="nextTrackBtn" title="ä¸‹ä¸€é¦–">â­ï¸</button>
            <div id="musicInfo" class="music-info">åŠ è½½ä¸­...</div>
        </div>
    </div>
    
    <audio id="backgroundMusic" loop></audio>

    <script>
        // --- DATA PLACEHOLDERS ---
        // The data will be loaded from external JSON files.
        let animeData = [];
        let musicTracks = [];
        let backgroundImages = [];

        // --- DOM ELEMENTS ---
        const tableBody = document.getElementById('animeTableBody');
        const searchInput = document.getElementById('searchInput');
        const tagFilterContainer = document.getElementById('tagFilterContainer');
        const modal = document.getElementById('detailsModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalContent = document.getElementById('modal-content-details');
        const closeBtn = document.getElementsByClassName("close-btn")[0];

        // --- STATE ---
        let currentSort = { column: 'date', direction: 'desc' };
        let selectedTags = [];

        // All other functions (renderTable, sortTable, etc.) remain the same as the previous version.
        // --- MODAL LOGIC ---
        function showModal(title, contentHTML) {
            modalTitle.textContent = title;
            modalContent.innerHTML = contentHTML;
            modal.style.display = "block";
        }
        closeBtn.onclick = () => modal.style.display = "none";
        window.onclick = (event) => { if (event.target == modal) modal.style.display = "none"; };

        // --- CALCULATION LOGIC ---
        const calculateRecommendationScore = (rec) => (rec.production * 0.3 + rec.plot * 0.4 + rec.character * 0.3).toFixed(2);
        const calculateFinalScore = (recScore, adjScore) => (parseFloat(recScore) + adjScore).toFixed(2);

        // --- RENDER LOGIC ---
        function renderTable() {
            tableBody.innerHTML = '';
            
            const filteredData = animeData.filter(anime => {
                const searchMatch = anime.name.toLowerCase().includes(searchInput.value.toLowerCase());
                const tagMatch = selectedTags.length === 0 || selectedTags.every(tag => anime.tags.includes(tag));
                return searchMatch && tagMatch;
            });
            
            filteredData.sort((a, b) => {
                let aVal, bVal;
                const getVal = (item, column) => {
                    switch (column) {
                        case 'production': return item.recommendation.production;
                        case 'plot': return item.recommendation.plot;
                        case 'character': return item.recommendation.character;
                        case 'recommendationScore': return calculateRecommendationScore(item.recommendation);
                        case 'adjustmentScore': return item.adjustments.score;
                        case 'finalScore': return calculateFinalScore(calculateRecommendationScore(item.recommendation), item.adjustments.score);
                        case 'date': return new Date(item.date);
                        default: return item[column];
                    }
                };
                aVal = getVal(a, currentSort.column);
                bVal = getVal(b, currentSort.column);

                if (currentSort.direction === 'asc') {
                    return typeof aVal === 'string' ? aVal.localeCompare(bVal) : aVal - bVal;
                } else {
                    return typeof aVal === 'string' ? bVal.localeCompare(aVal) : bVal - aVal;
                }
            });

            filteredData.forEach(anime => {
                const recommendationScore = calculateRecommendationScore(anime.recommendation);
                const finalScore = calculateFinalScore(recommendationScore, anime.adjustments.score);
                const adj = anime.adjustments;

                let adjustmentDetailsHTML = `
                    <p><strong>äº‰è®®å†…å®¹:</strong> ${adj.controversy || 'æ— '}</p>
                    <p><strong>å†…æ ¸æ·±åº¦:</strong> ${adj.depth || 'æ— '}</p>
                    <p><strong>ç¤¾ä¼šå½±å“:</strong> ${adj.impact || 'æ— '}</p>
                    <p><strong>è‰ºæœ¯è¡¨è¾¾:</strong> ${adj.artistry || 'æ— '}</p>
                `;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><img src="${anime.image}" alt="${anime.name}" class="anime-img"></td>
                    <td>${anime.name}</td>
                    <td><span class="score" onclick='showModal("${anime.name} - ä¸ªäººè¯„ä»·", "<p>${anime.personalEvaluation.replace(/"/g, '&quot;')}</p>")'>${anime.personalScore}</span></td>
                    <td><strong>${anime.recommendation.production}</strong><div class="details-comment">${anime.recommendation.productionComment}</div></td>
                    <td><strong>${anime.recommendation.plot}</strong><div class="details-comment">${anime.recommendation.plotComment}</div></td>
                    <td><strong>${anime.recommendation.character}</strong><div class="details-comment">${anime.recommendation.characterComment}</div></td>
                    <td><strong>${recommendationScore}</strong></td>
                    <td><span class="score" onclick='showModal("${anime.name} - åˆ†æ•°ä¿®æ­£è¯¦æƒ…", ${JSON.stringify(adjustmentDetailsHTML)})'>${adj.score > 0 ? '+' : ''}${adj.score}</span></td>
                    <td><strong>${finalScore}</strong></td>
                    <td class="tags">${anime.tags.map(tag => `<span>${tag}</span>`).join(' ')}</td>
                    <td>${anime.date}</td>
                    <td>${anime.bangumiScore}</td>
                `;
                tableBody.appendChild(row);
            });
            updateSortIndicators();
        }
        
        function renderTagFilters() {
            const allTags = [...new Set(animeData.flatMap(a => a.tags))];
            allTags.forEach(tag => {
                const button = document.createElement('button');
                button.textContent = tag;
                button.onclick = () => toggleTag(tag, button);
                tagFilterContainer.appendChild(button);
            });
        }

        // --- EVENT HANDLERS & HELPERS ---
        const filterTable = () => renderTable();
        
        function toggleTag(tag, button) {
            const index = selectedTags.indexOf(tag);
            if (index > -1) {
                selectedTags.splice(index, 1);
                button.classList.remove('active');
            } else {
                selectedTags.push(tag);
                button.classList.add('active');
            }
            renderTable();
        }

        function sortTable(column) {
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }
            renderTable();
        }
        
        function updateSortIndicators() {
            document.querySelectorAll('#animeTable th[data-sort]').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = 'â†•';
                
                if (th.dataset.sort === currentSort.column) {
                    th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
                    if(indicator) indicator.textContent = currentSort.direction === 'asc' ? 'â†‘' : 'â†“';
                }
            });
        }
        
        document.querySelectorAll('#animeTable th[data-sort]').forEach(header => {
            header.addEventListener('click', () => sortTable(header.dataset.sort));
        });

        // --- BACKGROUND & MUSIC CONTROLS ---
        let currentBgIndex = 0;
        let bgInterval;
        
        let currentTrackIndex = 0;
        const audio = document.getElementById('backgroundMusic');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const nextTrackBtn = document.getElementById('nextTrackBtn');
        const musicInfo = document.getElementById('musicInfo');

        function changeBackground(direction) {
            if (backgroundImages.length === 0) return;
            currentBgIndex = (currentBgIndex + direction + backgroundImages.length) % backgroundImages.length;
            document.body.style.backgroundImage = `url('${backgroundImages[currentBgIndex]}')`;
        }
        
        function startBgAutoplay() {
            if (backgroundImages.length > 1) {
                bgInterval = setInterval(() => changeBackground(1), 20000);
            }
        }

        function playPauseMusic() {
            if (musicTracks.length === 0) return;
            if (audio.paused) {
                if(!audio.src) changeTrack(0);
                audio.play();
                playPauseBtn.textContent = 'â¸ï¸';
            } else {
                audio.pause();
                playPauseBtn.textContent = 'â–¶ï¸';
            }
            updateMusicInfo();
        }
        
        function changeTrack(direction) {
            if (musicTracks.length === 0) return;
            currentTrackIndex = (currentTrackIndex + direction + musicTracks.length) % musicTracks.length;
            audio.src = musicTracks[currentTrackIndex].src;
            if (playPauseBtn.textContent === 'â¸ï¸') audio.play();
            updateMusicInfo();
        }
        
        function updateMusicInfo() {
            if (musicTracks.length === 0) {
                musicInfo.textContent = 'æ— éŸ³ä¹';
                return;
            }
            musicInfo.textContent = audio.paused ? 'æš‚åœä¸­' : musicTracks[currentTrackIndex].name;
            musicInfo.title = musicTracks[currentTrackIndex].name;
        }

        document.getElementById('prevBgBtn').onclick = () => { clearInterval(bgInterval); changeBackground(-1); startBgAutoplay(); };
        document.getElementById('nextBgBtn').onclick = () => { clearInterval(bgInterval); changeBackground(1); startBgAutoplay(); };
        playPauseBtn.onclick = playPauseMusic;
        nextTrackBtn.onclick = () => changeTrack(1);
        audio.onended = () => changeTrack(1);

        // --- INITIAL LOAD ---
        document.addEventListener('DOMContentLoaded', () => {
            // Fetch all data files at the same time
            Promise.all([
                fetch('animeData.json').then(res => res.json()),
                fetch('musicData.json').then(res => res.json()),
                fetch('backgrounds.json').then(res => res.json())
            ])
            .then(([loadedAnimeData, loadedMusicData, loadedBackgrounds]) => {
                // Once all data is loaded, assign it to our variables
                animeData = loadedAnimeData;
                musicTracks = loadedMusicData;
                backgroundImages = loadedBackgrounds;

                // Now, initialize the website with the loaded data
                renderTable();
                renderTagFilters();
                changeBackground(0);
                startBgAutoplay();
                updateMusicInfo();
            })
            .catch(error => {
                console.error("åŠ è½½æ ¸å¿ƒæ•°æ®å¤±è´¥:", error);
                document.body.innerHTML = `<h1 style="color:white; text-align:center; margin-top: 20vh;">æ— æ³•åŠ è½½ç½‘ç«™æ•°æ®ï¼Œè¯·æ£€æŸ¥JSONæ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®ã€‚</h1>`;
            });
        });

    </script>
</body>
</html>